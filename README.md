# ЛР5. Вариант 14, 24
### Проверка на палиндромию отрицательного числа в дополнительном коде _(14)_ и вещественного в двоичном _(24)_
В [`main.c`](./main.c) находится бесконечный цикл, который запускает по очереди проверку для 14го варианта, а потом для 24.

Реализация методов находится в [`solution.c`](./solution/solution.c)

Т.к. ТЗ совпало для обоих вариантов (проверка на палиндромию) – в `utils` были добавлены функции:
- `is_binary_palindrome`
- `print_is_binary_palindrome`
- `print_binary`

----



# Отчёт по лабораторной работе №5 по курсу "Фундаментальная информатика"

**Тема:** Представление целых и вещественных чисел в компьютере.

**Цель:** Изучить способы машинного представления целых и вещественных чисел в памяти компьютера. 
Освоить методы анализа двоичного представления чисел без использования строковых операций.

**Задание:** Проверить на палиндромию двоичную запись отрицательного целого числа в дополнительном коде. Аналогично с двоичным представлением вещественного числа.
> [!NOTE]  
> **Вариант №14:** Проверка двоичной записи  отрицательного числа в дополнительном коде на палиндромию.
> 
> **Вариант №24:** Вводится вещественное число. Проверить его двоичное машинное представление на палиндромию.

## Идея и метод решения
Ключевые идеи решения:
- Работа с битами ведётся через целочисленные типы фиксированной разрядности: `uint32_t` и `uint64_t`
- Проверка на палиндромию выполняется путём побитового разворота числа и последующего сравнения с исходным значением

Вещественные числа (`double`) интерпретируются как 64-битная последовательность без каких-либо преобразований к строкам.

> Обе задачи сводятся к проверке бинарного представления числа на палиндромию, поэтому было принято решение реализовать общий вспомогательный
> функционал для работы с битами.

## Структура программы
Программа декомпозирована на несколько файлов:

- `main.c` – точка входа, управляющая логикой запуска проверок
- `solution.c / solution.h` – реализация решений для вариантов 14 и 24
- `utils.c / utils.h` – вспомогательные функции для работы с бинарным представлением

Такое разделение позволяет избежать дублирования кода

## Алгоритм

### Проверка отрицательного целого числа (вариант 14)

1. Вводится целое число
2. Проверяется, что число отрицательное
3. Число приводится к типу `uint32_t`, что позволяет получить его двоичное представление в дополнительном коде
4. Выполняется проверка 32-битной последовательности на палиндромию
5. Результат проверки и двоичная запись числа выводятся на экран

### Проверка вещественного числа (вариант 24)

1. Вводится вещественное число типа `double`
2. Его битовое представление интерпретируется как `uint64_t`
3. Выполняется проверка 64-битной последовательности на палиндромию
4. Для наглядности выводится двоичное представление числа с разделением на знак, порядок, мантиссу
5. Результат проверки выводится на экран

    > Для вывода вещественного числа в десятичной системе счисления кол-во знаков после запятой ограничено (`%lf`)

> [!IMPORTANT]
> **Проверка на палиндромию**:
> - Биты исходного числа последовательно считываются справа налево
> - Формируется новое число, представляющее собой побитовый разворот исходного
> - Полученное число сравнивается с оригиналом
>   
> Если значения совпадают, бинарное представление является палиндромом.

## Сценарий выполнения работы

1. Анализ условия заданий и ограничений (запрет на строковое представление)
2. Изучение формата представления целых чисел в дополнительном коде и вещественных в двоичном
3. Реализация функции проверки бинарной последовательности на палиндромию
4. Реализация вывода двоичного представления чисел
5. **Тестирование**
> #14
> | **Ввод** | **Биты (32)** | **Палиндромия** |
> |:---------:|:-------------:|:--------------:|
> | -1        | 11111111111111111111111111111111 | ✅ |
> | -268435441 | 11110000000000000000000000001111 | ✅ |
> | -2        | 11111111111111111111111111111110 | ❌ |
> | -2147483648 | 10000000000000000000000000000000 | ❌ |
> | -1431655766 | 10101010101010101010101010101010 | ❌ |

> #24
> | **Ввод** | **Биты (64)** | **Палиндромия** |
> |:---------:|:-------------:|:--------------:|
> | 0.0       | 0\|00000000000\|0000000000000000000000000000000000000000000000000000 | ✅ |
> | -4.9406564584124654e-324 | 1\|00000000000\|0000000000000000000000000000000000000000000000000001 | ✅ |
> | -0.0      | 1\|00000000000\|0000000000000000000000000000000000000000000000000000 | ❌ |
> | 1.0       | 0\|01111111111\|0000000000000000000000000000000000000000000000000000| ❌ |
> | -1.0      | 1\|01111111111\|0000000000000000000000000000000000000000000000000000 | ❌ |
> | NaN       | 0\|11111111111\|1000000000000000000000000000000000000000000000000000 | ❌ |
> | inf       | 0\|11111111111\|0000000000000000000000000000000000000000000000000000 | ❌ |


## Выводы

В ходе выполнения лабораторной работы были изучены особенности машинного представления целых и вещественных чисел в памяти компьютера.

Особую ценность представляет понимание того, что операции анализа битов не требуют строковых преобразований и могут быть эффективно реализованы с 
использованием побитовых операций.

Работа также продемонстрировала важность декомпозиции программы на модули и повторного использования общего функционала при решении нескольких логически схожих задач.

